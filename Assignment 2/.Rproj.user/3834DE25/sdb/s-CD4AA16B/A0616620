{
    "collab_server" : "",
    "contents" : "# Jags-Ymet-XmetMulti-Mrobust.R \n# Accompanies the book:\n#  Kruschke, J. K. (2015). Doing Bayesian Data Analysis, Second Edition: \n#  A Tutorial with R, JAGS, and Stan. Academic Press / Elsevier.\n\nsource(\"DBDA2E-utilities.R\")\n\n#===============================================================================\n\ngenMCMC = function( data , xName=\"x\" , yName=\"y\" , \n                    numSavedSteps=numSavedSteps , thinSteps=thinSteps , saveName=NULL  ,\n                    runjagsMethod=runjagsMethodDefault , \n                    nChains=3) { \n  require(runjags)\n  #-----------------------------------------------------------------------------\n  # THE DATA.\n  y = data[,yName]\n  x = as.matrix(data[,xName],ncol=length(xName))\n  # Do some checking that data make sense:\n  if ( any( !is.finite(y) ) ) { stop(\"All y values must be finite.\") }\n  if ( any( !is.finite(x) ) ) { stop(\"All x values must be finite.\") }\n  cat(\"\\nCORRELATION MATRIX OF PREDICTORS:\\n \")\n  show( round(cor(x),3) )\n  cat(\"\\n\")\n  flush.console()\n  # Specify the data in a list, for later shipment to JAGS:\n  dataList = list(\n    x = x ,\n    y = y ,\n    Nx = dim(x)[2] ,\n    Ntotal = dim(x)[1]\n  )\n  #-----------------------------------------------------------------------------\n  # THE MODEL.\n  modelString = \"\n  # Standardize the data:\n  data {\n    ym <- mean(y)\n    ysd <- sd(y)\n    for ( i in 1:Ntotal ) {\n      zy[i] <- ( y[i] - ym ) / ysd\n    }\n    for ( j in 1:Nx ) {\n      xm[j]  <- mean(x[,j])\n      xsd[j] <-   sd(x[,j])\n      for ( i in 1:Ntotal ) {\n        zx[i,j] <- ( x[i,j] - xm[j] ) / xsd[j]\n      }\n    }\n\n    # Specify the priors for original beta parameters\n    # Prior locations to reflect the expert information\n    mu0 <- ym # Set to overall mean a priori based on the interpretation of constant term in regression\n    mu[1] <- 90 # Area\n    mu[2] <- 100000 # Bedrooms\n    mu[3] <- 609360.2 # Bathrooms, muY\n    mu[4] <- 120000 # CarParks\n    mu[5] <- 0.5 # PropertyType\n\n    # Prior variances to reflect the expert information    \n    Var0 <- ((ysd^2)*40000)\n    Var[1] <- ((ysd^2)*0.01) # Area\n    Var[2] <- ((ysd^2)*0.75) # Bedrooms\n    Var[3] <- ((ysd^2)*100) # Bathrooms\n    Var[4] <- ((ysd^2)*0.1) # CarParks\n    Var[5] <- ((ysd^2)*0.01)\n\n    # Compute corresponding prior means and variances for the standardised parameters\n    muZ[1:Nx] <-  mu[1:Nx] * xsd[1:Nx] / ysd \n\n    muZ0 <- (mu0 + sum( mu[1:Nx] * xm[1:Nx] / xsd[1:Nx] )*ysd - ym) / ysd \n\n    # Compute corresponding prior variances and variances for the standardised parameters\n    VarZ[1:Nx] <- Var[1:Nx] * ( xsd[1:Nx]/ ysd )^2\n    VarZ0 <- Var0 / (ysd^2)\n\n  }\n  # Specify the model for standardized data:\n  model {\n    for ( i in 1:Ntotal ) {\n      zy[i] ~ dt( zbeta0 + sum( zbeta[1:Nx] * zx[i,1:Nx] ) , 1/zsigma^2 , nu )\n    }\n\n    # Priors vague on standardized scale:\n    zbeta0 ~ dnorm( muZ0 , 1/VarZ0 )  \n    for ( j in 1:Nx ) {\n      zbeta[j] ~ dnorm( muZ[j] , 1/VarZ[j] )\n    }\n    zsigma ~ dgamma(0.01,0.01)#dunif( 1.0E-5 , 1.0E+1 )\n    nu ~ dexp(1/30.0)\n\n    # Transform to original scale:\n    beta[1:Nx] <- ( zbeta[1:Nx] / xsd[1:Nx] )*ysd\n    beta0 <- zbeta0*ysd  + ym - sum( zbeta[1:Nx] * xm[1:Nx] / xsd[1:Nx] )*ysd\n    sigma <- zsigma*ysd\n\n    # Compute predictions at every step of the MCMC\n    # pred <- beta0 + beta[1] * xPred[1] + beta[2] * xPred[2] + beta[3] * xPred[3] + beta[4] * xPred[4] \n    #         + beta[5] * xPred[5] + beta[6] * xPred[6] + beta[7] * xPred[7] \n\n  }\n  \" # close quote for modelString\n  # Write out modelString to a text file\n  writeLines( modelString , con=\"TEMPmodel.txt\" )\n  #-----------------------------------------------------------------------------\n  # INTIALIZE THE CHAINS.\n  # Let JAGS do it...\n  \n  # Must standardize data first...\n  #   lmInfo = lm( zy ~ zx )\n  #   initsList = list(\n  #     beta0 = lmInfo$coef[1] ,   \n  #     beta = lmInfo$coef[-1] ,        \n  #     sigma = sqrt(mean(lmInfo$resid^2)) ,\n  #     nu = 5\n  #   )\n  \n  \n  #-----------------------------------------------------------------------------\n  # RUN THE CHAINS\n  parameters = c( \"beta0\" ,  \"beta\" ,  \"sigma\", \n                  \"zbeta0\" , \"zbeta\" , \"zsigma\", \"nu\")\n  adaptSteps = 2500  # Number of steps to \"tune\" the samplers\n  burnInSteps = 500\n  runJagsOut <- run.jags( method=runjagsMethod ,\n                          model=\"TEMPmodel.txt\" , \n                          monitor=parameters , \n                          data=dataList ,  \n                          #inits=initsList , \n                          n.chains=nChains ,\n                          adapt=adaptSteps ,\n                          burnin=burnInSteps , \n                          sample=ceiling(numSavedSteps/nChains) ,\n                          thin=thinSteps ,\n                          summarise=FALSE ,\n                          plots=FALSE )\n  codaSamples = as.mcmc.list( runJagsOut )\n\n  if ( !is.null(saveName) ) {\n    save( codaSamples , file=paste(saveName,\"Mcmc.Rdata\",sep=\"\") )\n  }\n  return( codaSamples )\n} # end function\n\n#===============================================================================\n\nsmryMCMC = function(  codaSamples , \n                      saveName=NULL) {\n  summaryInfo = NULL\n  mcmcMat = as.matrix(codaSamples,chains=TRUE)\n  paramName = colnames(mcmcMat)\n  for ( pName in paramName ) {\n    summaryInfo = rbind( summaryInfo , summarizePost( mcmcMat[,pName] ) )\n  }\n  rownames(summaryInfo) = paramName\n  summaryInfo = rbind( summaryInfo , \n                       \"log10(nu)\" = summarizePost( log10(mcmcMat[,\"nu\"]) ) )\n  if ( !is.null(saveName) ) {\n    write.csv( summaryInfo , file=paste(saveName,\"SummaryInfo.csv\",sep=\"\") )\n  }\n  \n  return( summaryInfo)\n}\n\n#===============================================================================\n\nplotMCMC = function( codaSamples , data , xName=\"x\" , yName=\"y\" ,\n                     showCurve=FALSE ,  pairsPlot=FALSE ,\n                     saveName=NULL , saveType=\"jpg\" ) {\n  # showCurve is TRUE or FALSE and indicates whether the posterior should\n  #   be displayed as a histogram (by default) or by an approximate curve.\n  # pairsPlot is TRUE or FALSE and indicates whether scatterplots of pairs\n  #   of parameters should be displayed.\n  #-----------------------------------------------------------------------------\n  y = data[,yName]\n  x = as.matrix(data[,xName])\n  mcmcMat = as.matrix(codaSamples,chains=TRUE)\n  chainLength = NROW( mcmcMat )\n  zbeta0 = mcmcMat[,\"zbeta0\"]\n  zbeta  = mcmcMat[,grep(\"^zbeta$|^zbeta\\\\[\",colnames(mcmcMat))]\n  if ( ncol(x)==1 ) { zbeta = matrix( zbeta , ncol=1 ) }\n  zsigma = mcmcMat[,\"zsigma\"]\n  beta0 = mcmcMat[,\"beta0\"]\n  beta  = mcmcMat[,grep(\"^beta$|^beta\\\\[\",colnames(mcmcMat))]\n  if ( ncol(x)==1 ) { beta = matrix( beta , ncol=1 ) }\n  sigma = mcmcMat[,\"sigma\"]\n  nu = mcmcMat[,\"nu\"]\n  log10nu = log10(nu)\n  # pred = mcmcMat[,\"pred\"] # Added by Demirhan\n  #-----------------------------------------------------------------------------\n  # Compute R^2 for credible parameters:\n  YcorX = cor( y , x ) # correlation of y with each x predictor\n  Rsq = zbeta %*% matrix( YcorX , ncol=1 )\n  #-----------------------------------------------------------------------------\n  if ( pairsPlot ) {\n    # Plot the parameters pairwise, to see correlations:\n    openGraph()\n    nPtToPlot = 1000\n    plotIdx = floor(seq(1,chainLength,by=chainLength/nPtToPlot))\n    panel.cor = function(x, y, digits=2, prefix=\"\", cex.cor, ...) {\n      usr = par(\"usr\"); on.exit(par(usr))\n      par(usr = c(0, 1, 0, 1))\n      r = (cor(x, y))\n      txt = format(c(r, 0.123456789), digits=digits)[1]\n      txt = paste(prefix, txt, sep=\"\")\n      if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)\n      text(0.5, 0.5, txt, cex=1.25 ) # was cex=cex.cor*r\n    }\n    pairs( cbind( beta0 , beta , sigma , log10nu )[plotIdx,] ,\n           labels=c( \"beta[0]\" , \n                     paste0(\"beta[\",1:ncol(beta),\"]\\n\",xName) , \n                     expression(sigma) ,  expression(log10(nu)) ) , \n           lower.panel=panel.cor , col=\"skyblue\" )\n    if ( !is.null(saveName) ) {\n      saveGraph( file=paste(saveName,\"PostPairs\",sep=\"\"), type=saveType)\n    }\n  }\n  #-----------------------------------------------------------------------------\n  # Marginal histograms:\n  \n  decideOpenGraph = function( panelCount , saveName , finished=FALSE , \n                              nRow=2 , nCol=3 ) {\n    # If finishing a set:\n    if ( finished==TRUE ) {\n      if ( !is.null(saveName) ) {\n        saveGraph( file=paste0(saveName,ceiling((panelCount-1)/(nRow*nCol))), \n                   type=saveType)\n      }\n      panelCount = 1 # re-set panelCount\n      return(panelCount)\n    } else {\n    # If this is first panel of a graph:\n    if ( ( panelCount %% (nRow*nCol) ) == 1 ) {\n      # If previous graph was open, save previous one:\n      if ( panelCount>1 & !is.null(saveName) ) {\n        saveGraph( file=paste0(saveName,(panelCount%/%(nRow*nCol))), \n                   type=saveType)\n      }\n      # Open new graph\n      openGraph(width=nCol*7.0/3,height=nRow*2.0)\n      layout( matrix( 1:(nRow*nCol) , nrow=nRow, byrow=TRUE ) )\n      par( mar=c(4,4,2.5,0.5) , mgp=c(2.5,0.7,0) )\n    }\n    # Increment and return panel count:\n    panelCount = panelCount+1\n    return(panelCount)\n    }\n  }\n  \n  # Original scale:\n  panelCount = 1\n  panelCount = decideOpenGraph( panelCount , saveName=paste0(saveName,\"PostMarg\") )\n  histInfo = plotPost( beta0 , cex.lab = 1.75 , showCurve=showCurve ,\n                       xlab=bquote(beta[0]) , main=\"Intercept\" )\n  for ( bIdx in 1:ncol(beta) ) {\n    panelCount = decideOpenGraph( panelCount , saveName=paste0(saveName,\"PostMarg\") )\n    histInfo = plotPost( beta[,bIdx] , cex.lab = 1.75 , showCurve=showCurve ,\n                         xlab=bquote(beta[.(bIdx)]) , main=xName[bIdx] )\n  }\n  panelCount = decideOpenGraph( panelCount , saveName=paste0(saveName,\"PostMarg\") )\n  histInfo = plotPost( sigma , cex.lab = 1.75 , showCurve=showCurve ,\n                       xlab=bquote(sigma) , main=paste(\"Scale\") )\n  panelCount = decideOpenGraph( panelCount , saveName=paste0(saveName,\"PostMarg\") )\n  histInfo = plotPost( log10nu , cex.lab = 1.75 , showCurve=showCurve ,\n                       xlab=bquote(log10(nu)) , main=paste(\"Normality\") )\n  panelCount = decideOpenGraph( panelCount , saveName=paste0(saveName,\"PostMarg\") )\n  histInfo = plotPost( Rsq , cex.lab = 1.75 , showCurve=showCurve ,\n                       xlab=bquote(R^2) , main=paste(\"Prop Var Accntd\") )\n  panelCount = decideOpenGraph( panelCount , finished=TRUE , saveName=paste0(saveName,\"PostMarg\") )\n  # histInfo = plotPost( pred , cex.lab = 1.75 , showCurve=showCurve ,\n  #                      xlab=bquote(pred) , main=\"Prediction\" ) # Added by Demirhan\n  # Standardized scale:\n  panelCount = 1\n  panelCount = decideOpenGraph( panelCount , saveName=paste0(saveName,\"PostMargZ\") )\n  histInfo = plotPost( zbeta0 , cex.lab = 1.75 , showCurve=showCurve ,\n                       xlab=bquote(z*beta[0]) , main=\"Intercept\" )\n  for ( bIdx in 1:ncol(beta) ) {\n    panelCount = decideOpenGraph( panelCount , saveName=paste0(saveName,\"PostMargZ\") )\n    histInfo = plotPost( zbeta[,bIdx] , cex.lab = 1.75 , showCurve=showCurve ,\n                         xlab=bquote(z*beta[.(bIdx)]) , main=xName[bIdx] )\n  }\n  panelCount = decideOpenGraph( panelCount , saveName=paste0(saveName,\"PostMargZ\") )\n  histInfo = plotPost( zsigma , cex.lab = 1.75 , showCurve=showCurve ,\n                       xlab=bquote(z*sigma) , main=paste(\"Scale\") )\n  panelCount = decideOpenGraph( panelCount , saveName=paste0(saveName,\"PostMargZ\") )\n  histInfo = plotPost( log10nu , cex.lab = 1.75 , showCurve=showCurve ,\n                       xlab=bquote(log10(nu)) , main=paste(\"Normality\") )\n  panelCount = decideOpenGraph( panelCount , saveName=paste0(saveName,\"PostMargZ\") )\n  histInfo = plotPost( Rsq , cex.lab = 1.75 , showCurve=showCurve ,\n                       xlab=bquote(R^2) , main=paste(\"Prop Var Accntd\") )\n  panelCount = decideOpenGraph( panelCount , finished=TRUE , saveName=paste0(saveName,\"PostMargZ\") )\n  \n  #-----------------------------------------------------------------------------\n}\n#===============================================================================\n",
    "created" : 1537841733949.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4039065830",
    "id" : "A0616620",
    "lastKnownWriteTime" : 1537947605,
    "last_content_update" : 1537947605367,
    "path" : "~/RMIT/2018 RMIT SEM 2/Applied Bayesian Statistics/Assignment 2/Jags-Ymet-XmetMulti-Mrobust-Assn2.R",
    "project_path" : "Jags-Ymet-XmetMulti-Mrobust-Assn2.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}