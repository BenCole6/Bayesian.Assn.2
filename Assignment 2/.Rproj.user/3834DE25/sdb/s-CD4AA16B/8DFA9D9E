{
    "collab_server" : "",
    "contents" : "setwd(\"~/Documents/MATH2269_Bayesian/tasks/Module5\")\n### SOLUTION OF MODULE 5 -- TASK 3 and TASK 4 ###\n\n### TASK 3 ###\n# Please refer to the Task 3 of Module 4. Run 4 chains of length 1000 and display MCMC diagnostics.\n\n## Write a function to compute the likelihood with inputs of mu, sigma, and theta which applies the pdf of the normal likelihood.\nlikelihood = function( mu , sigma , sample_average ) { # mu and sigma are the parameters of the likelihood\n  z = sample_average # To find the sum of sample from the given sample average and sample size\n  pDataGivenMu = (1/sqrt(2*pi)) * exp( -0.5 * n * (z - mu)/(sigma^2) ) # This computes the normal likelihood\n  return( pDataGivenMu )\n}\n\n## Write a function to compute prior distribution with inputs of mu and sigma which applies the pdf of the normal distribution.\nprior = function( mu , mu_prior , sigma_prior ) {# mu_prior and sigma_prior are the mean and standard deviation of normal prior\n  pMu = dnorm( mu , mu_prior , sigma_prior )\n  return( pMu )\n}\n\n## Write a function to calculate the target distribution multiplying the value of likelihood and prior for the current value of mu.\ntargetRelProb = function( mu , sigma , mu_prior , sigma_prior , sample_average ) {\n  targetRelProb =  likelihood( mu , sigma , sample_average ) * prior( mu , mu_prior , sigma_prior )\n  return( targetRelProb )\n}\n\n## Write a code chunk to set the details of the Metropolis algorithm.\n\n# Specify the length of the trajectory, i.e., the number of jumps to try:\ntrajLength = 500 # arbitrary large number\n\n# Specify the burn-in period:\nburnIn = ceiling( 0.0 * trajLength ) # arbitrary number, less than trajLength\n# Initialize accepted, rejected counters, just to monitor performance:\nnAccepted = 0\nnRejected = 0\nproposalSD = 0.1 # Specify standard deviation of proposal distribution:\n\nsigma = 12 # The population variance. This is given in the Task 3.\nsample_average = 32 # This is given in the Task 3.\nn = 10 # !0 observations taken\n\n# Specify the prior information - \n# In Task 3, it's mentioned that An expert in this field strongly believes that the half-life of this isotope is 20 seconds.\nmu_prior = 20    # Prior mode = mean = median due to the symmetry of the normal distribution. This is given in the Task 3.\nsigma_prior = 10 # The strong degree of belief in the prior information.  \n\n\n# Because we have more than one chain, initialize the vectors that will store the results:\nnumChain = 4\ntrajectory = matrix( 0 , trajLength , numChain) # 4 is the number of chains here.\n# Specify where to start the trajectory:\ntrajectory[1 , ] = 0.5 # arbitrary value for the staring point of all chains\n\nacceptedTraj = matrix( 0 ,  length(trajectory) - burnIn , numChain) # Another matrix to hold the trajectories after the burnin period\\\n\n## Write a code chunk that creates the trajectory of the Markov chain by proposing jumps from \n## the normal distribution, calculating the acceptance probability and deciding on acceptance of the proposed moves.\nfor (k in 1:numChain){ #Add another for loop to generate numChain = 4 chains \n  for ( t in 1:(trajLength - 1) ) { #The 't' index is time or trial in the walk.\n    #recodr the current positio of the chain.\n    currentPosition = trajectory[t , k] \n    # Use the proposal distribution to generate a proposed jump.\n    proposedJump = rnorm( 1 , mean=0 , sd=proposalSD ) \n    # Compute the probability of accepting the proposed jump.\n    probAccept = min( 1,\n                      targetRelProb( mu = currentPosition + proposedJump , sigma , mu_prior , sigma_prior , sample_average )\n                      / targetRelProb( mu = currentPosition , sigma , mu_prior , sigma_prior , sample_average ) )\n    # Generate a random uniform value from the interval [0,1] to \n    # decide whether or not to accept the proposed jump.\n    if ( runif(1) < probAccept ) {# accept the proposed jump\n      # add the jump length to the currrent position.\n      trajectory[ t+1 , k] = currentPosition + proposedJump \n      if ( t > burnIn ) { \n        # increment the accepted counter, just to monitor performance\n        nAccepted = nAccepted + 1\t\n      }\n    } else {\n      # reject the proposed jump, stay at current position\n      trajectory[ t+1 , k] = currentPosition # stay where you are.\n      if ( t > burnIn ) { \n        # increment the rejected counter, just to monitor performance\n        nRejected = nRejected + 1 \n      }\n    }\n  }\n  # Extract the post-burnIn portion of the trajectory.\n  acceptedTraj[ , k] = trajectory[ (burnIn+1) : trajLength , k]\n}\n\n\n\n# Use of code package to visualise the posterior distribution\nlibrary(coda)\ntrajectory = array( 0 , dim = c(numChain , 1 , length(trajectory) - burnIn) ) # Set 1 to the number of parameters for multi-parmater case.\nfor ( i in 1:numChain){\n  trajectory[ i , 1 , ] = acceptedTraj[ , i]\n}\nfor (i in 1:1){# Set 1 to the number of parameters for multi-parmater case.\n  traceData = data.frame(trajectory[ 1 , i , ], trajectory[ 2 , i , ], trajectory[ 3 , i , ], trajectory[ 4 , i , ])\n  obj = as.mcmc.list(lapply(traceData, mcmc)) \n}\n\nplot(obj)\ngelman.plot(obj, confidence = 0.95, transform=FALSE, autoburnin=TRUE)\nautocorr.plot(obj, lag.max=10, auto.layout = FALSE)\ndiagMCMC(obj)\n\n\n\n### TASK 4 ###\n\n# Read and prepare data\nmyData = read.csv(\"dataEinstein.csv\") # Read the data file; result is a data.frame.\ny = myData$y # The y values are the component named y.\nNtotal = length(y) # Compute the total number of flips.\ndataList = list( # Put the information into a list.\n  y = y ,\n  Ntotal = Ntotal\n)\n\nsqrt(var(y)) # Sample variance. I'll use this value in the model specification\n\n# Specify the normal - normal model\nmodelString = \" # open quote for modelString\nmodel {\n  for ( i in 1:Ntotal ) {\n    y[i] ~ dnorm( mu , 0.4609682 ) # Use sample variance as an estimate of the population variance\n  }\n  mu ~ dnorm( 1.75 , 0.1 ) # Here set the prior variance to a value smaller than the sample variance\n}\n\" # close quote for modelString\nwriteLines( modelString , con=\"TEMPmodel.txt\" ) # write to file\n\n# Compile the model\nlibrary(rjags) # you need to load the package rjags into R here or at early stages\njagsModel = jags.model( file=\"TEMPmodel.txt\" , # the name of the file in which the model \n                        # specification is stored\n                        data=dataList ,        # the list of data\n                        # to let JAGS to create its own initial values for the chains, \n                        # simply omit this argument entirely\n                        n.chains=3 ,           # the number of chains to be generated\n                        n.adapt=500            # the number of steps to take for adapting \n                        # (or tuning) the samplers\n)\n\nupdate( jagsModel ,   # tell the name of the object that include the model to JAGS\n        n.iter=500    # specify the length of the burn-in period\n)\n\ncodaSamples = coda.samples( jagsModel ,                 # previously created JAGS model object\n                            variable.names=c(\"mu\") , # specify which parameters will have \n                            # their values recorded during the \n                            # MCMC walk\n                            n.iter=3334                 # specify the number of iterations for \n                            # each chain\n)\n\n# Display MCMC diagnostics\ndiagMCMC( codaObject=codaSamples , parName=\"mu\" )\n\n# Display the posterior distribution of mu\nplotPost( codaSamples[,\"mu\"] , # the element of the posterior samples to be plotted\n          main=\"mu\" ,          # main title    \n          xlab=bquote(mu)      # x-axis label\n)",
    "created" : 1537236080555.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4237587291",
    "id" : "8DFA9D9E",
    "lastKnownWriteTime" : 1537229184,
    "last_content_update" : 1537229184,
    "path" : "~/RMIT/2018 RMIT SEM 2/Applied Bayesian Statistics/Solution_Task5.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}