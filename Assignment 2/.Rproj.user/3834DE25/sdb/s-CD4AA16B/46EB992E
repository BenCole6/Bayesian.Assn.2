{
    "collab_server" : "",
    "contents" : "\n### SOLUTION OF MODULE 4 -- TASK 2 and TASK 3 ###\n# Implementation of Metropolis algorithm with the Normal - Normal model\n\n## Write a function to compute the likelihood with inputs of mu, sigma, and theta which applies the pdf of the normal likelihood.\nlikelihood = function( mu , sigma , sample_average ) { # mu and sigma are the parameters of the likelihood\n  z = sample_average # To find the sum of sample from the given sample average and sample size\n  pDataGivenMu = (1/sqrt(2*pi)) * exp( -0.5 * n * (z - mu)/(sigma^2) ) # This computes the normal likelihood\n  return( pDataGivenMu )\n}\n\n## Write a function to compute prior distribution with inputs of mu and sigma which applies the pdf of the normal distribution.\nprior = function( mu , mu_prior , sigma_prior ) {# mu_prior and sigma_prior are the mean and standard deviation of normal prior\n  pMu = dnorm( mu , mu_prior , sigma_prior )\n  return( pMu )\n}\n\n## Write a function to calculate the target distribution multiplying the value of likelihood and prior for the current value of mu.\ntargetRelProb = function( mu , sigma , mu_prior , sigma_prior , sample_average ) {\n  targetRelProb =  likelihood( mu , sigma , sample_average ) * prior( mu , mu_prior , sigma_prior )\n  return( targetRelProb )\n}\n\n## Write a code chunk to set the details of the Metropolis algorithm.\n\n# Specify the length of the trajectory, i.e., the number of jumps to try:\ntrajLength = 50000 # arbitrary large number\n# Initialize the vector that will store the results:\ntrajectory = rep( 0 , trajLength )\n# Specify where to start the trajectory:\ntrajectory[1] = 0.5 # arbitrary value\n# Specify the burn-in period:\nburnIn = ceiling( 0.0 * trajLength ) # arbitrary number, less than trajLength\n# Initialize accepted, rejected counters, just to monitor performance:\nnAccepted = 0\nnRejected = 0\nproposalSD = 0.1 # Specify standard deviation of proposal distribution:\n\nsigma = 12 # The population variance. This is given in the Task 3.\nsample_average = 32 # This is given in the Task 3.\nn = 10 # !0 observations taken\n\n# Specify the prior information - \n# In Task 3, it's mentioned that An expert in this field strongly believes that the half-life of this isotope is 20 seconds.\nmu_prior = 20    # Prior mode = mean = median due to the symmetry of the normal distribution. This is given in the Task 3.\nsigma_prior = 10 # The strong degree of belief in the prior information.  \n\n\n## Write a code chunk that creates the trajectory of the Markov chain by proposing jumps from \n## the normal distribution, calculating the acceptance probability and deciding on acceptance of the proposed moves.\n\nfor ( t in 1:(trajLength-1) ) { #The 't' index is time or trial in the walk.\n  #recodr the current positio of the chain.\n  currentPosition = trajectory[t] \n  # Use the proposal distribution to generate a proposed jump.\n  proposedJump = rnorm( 1 , mean=0 , sd=proposalSD ) \n  # Compute the probability of accepting the proposed jump.\n  probAccept = min( 1,\n                    targetRelProb( mu = currentPosition + proposedJump , sigma , mu_prior , sigma_prior , sample_average )\n                    / targetRelProb( mu = currentPosition , sigma , mu_prior , sigma_prior , sample_average ) )\n  # Generate a random uniform value from the interval [0,1] to \n  # decide whether or not to accept the proposed jump.\n  if ( runif(1) < probAccept ) {# accept the proposed jump\n    # add the jump length to the currrent position.\n    trajectory[ t+1 ] = currentPosition + proposedJump \n    if ( t > burnIn ) { \n      # increment the accepted counter, just to monitor performance\n      nAccepted = nAccepted + 1\t\n    }\n  } else {\n    # reject the proposed jump, stay at current position\n    trajectory[ t+1 ] = currentPosition # stay where you are.\n    if ( t > burnIn ) { \n      # increment the rejected counter, just to monitor performance\n      nRejected = nRejected + 1 \n    }\n  }\n}\n# Extract the post-burnIn portion of the trajectory.\nacceptedTraj = trajectory[ (burnIn+1) : length(trajectory) ]\n\n# Use of code package to visualise the posterior distribution\nlibrary(coda)\n\nacceptedTraj.mcmc = as.mcmc(acceptedTraj) # Convert generated chain to a coda object\nsummary(acceptedTraj.mcmc) # Display summary statistics\nplot(acceptedTraj.mcmc) # Display posterior plots\n\n",
    "created" : 1537229320005.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3080932755",
    "id" : "46EB992E",
    "lastKnownWriteTime" : 1537229316,
    "last_content_update" : 1537229316,
    "path" : "~/RMIT/2018 RMIT SEM 2/Applied Bayesian Statistics/Solution_Task4.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}